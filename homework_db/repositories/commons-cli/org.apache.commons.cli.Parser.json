{"name":"org.apache.commons.cli.Parser","jDoctorConditions":[{"source":{"methodJavadoc":"    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */","methodSourceCode":"protected void checkRequiredOptions() throws MissingOptionException{\n    // if there are required options that have not been processed\n    if (!getRequiredOptions().isEmpty()) {\n        throw new MissingOptionException(getRequiredOptions());\n    }\n}","classSourceCode":"/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * {@code Parser} creates {@link CommandLine}s.\n *\n * @deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\n@Deprecated\npublic abstract class Parser implements CommandLineParser {\n\n    /**\n     * CommandLine instance\n     */\n    protected CommandLine cmd;\n\n    /**\n     * current Options\n     */\n    private Options options;\n\n    /**\n     * list of required options strings\n     */\n    private List requiredOptions;\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Subclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Gets the options.\n     *\n     * @return the options.\n     */\n    protected Options getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return the required options.\n     */\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @return the {@code CommandLine}\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the {@code CommandLine}\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, String[] arguments, final Properties properties, final boolean stopAtNonOption) throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = new CommandLine();\n        boolean eatTheRest = false;\n        if (arguments == null) {\n            arguments = new String[0];\n        }\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String t = iterator.next();\n            // the value is the double-dash\n            if (\"--\".equals(t)) {\n                eatTheRest = true;\n            } else // the value is a single dash\n            if (\"-\".equals(t)) {\n                if (stopAtNonOption) {\n                    eatTheRest = true;\n                } else {\n                    cmd.addArg(t);\n                }\n            } else // the value is an option\n            if (t.startsWith(\"-\")) {\n                if (stopAtNonOption && !getOptions().hasOption(t)) {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                } else {\n                    processOption(t, iterator);\n                }\n            } else // the value is an argument\n            {\n                cmd.addArg(t);\n                if (stopAtNonOption) {\n                    eatTheRest = true;\n                }\n            }\n            // eat the remaining tokens\n            if (eatTheRest) {\n                while (iterator.hasNext()) {\n                    final String str = iterator.next();\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str)) {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Process the argument values for the specified Option {@code opt} using the values retrieved from the specified\n     * iterator {@code iter}.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     *\n     * @throws ParseException if an argument value is required and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if {@code arg} does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (opt.getValues() == null || opt.getValues().length == 0) {\n                        try {\n                            opt.addValueForProcessing(value);\n                        } catch (final RuntimeException exp) {\n                            // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Sets the options.\n     *\n     * @param options the options.\n     */\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }\n}\n","_id":"654c9688beaabc9396c879bd"},"operation":{"name":"checkRequiredOptions","parameterTypes":[],"_id":"654c9688beaabc9396c879be"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654c9688beaabc9396c879bf"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if {@code arg} does not represent an Option\n     */","methodSourceCode":"protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException{\n    final boolean hasOption = getOptions().hasOption(arg);\n    // if there is no option throw an UnrecognizedOptionException\n    if (!hasOption) {\n        throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n    }\n    // get the option represented by arg\n    final Option opt = (Option) getOptions().getOption(arg).clone();\n    // update the required options and groups\n    updateRequiredOptions(opt);\n    // if the option takes an argument value\n    if (opt.hasArg()) {\n        processArgs(opt, iter);\n    }\n    // set the option on the command line\n    cmd.addOption(opt);\n}","classSourceCode":"/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * {@code Parser} creates {@link CommandLine}s.\n *\n * @deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\n@Deprecated\npublic abstract class Parser implements CommandLineParser {\n\n    /**\n     * CommandLine instance\n     */\n    protected CommandLine cmd;\n\n    /**\n     * current Options\n     */\n    private Options options;\n\n    /**\n     * list of required options strings\n     */\n    private List requiredOptions;\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Subclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Gets the options.\n     *\n     * @return the options.\n     */\n    protected Options getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return the required options.\n     */\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @return the {@code CommandLine}\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the {@code CommandLine}\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, String[] arguments, final Properties properties, final boolean stopAtNonOption) throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = new CommandLine();\n        boolean eatTheRest = false;\n        if (arguments == null) {\n            arguments = new String[0];\n        }\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String t = iterator.next();\n            // the value is the double-dash\n            if (\"--\".equals(t)) {\n                eatTheRest = true;\n            } else // the value is a single dash\n            if (\"-\".equals(t)) {\n                if (stopAtNonOption) {\n                    eatTheRest = true;\n                } else {\n                    cmd.addArg(t);\n                }\n            } else // the value is an option\n            if (t.startsWith(\"-\")) {\n                if (stopAtNonOption && !getOptions().hasOption(t)) {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                } else {\n                    processOption(t, iterator);\n                }\n            } else // the value is an argument\n            {\n                cmd.addArg(t);\n                if (stopAtNonOption) {\n                    eatTheRest = true;\n                }\n            }\n            // eat the remaining tokens\n            if (eatTheRest) {\n                while (iterator.hasNext()) {\n                    final String str = iterator.next();\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str)) {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Process the argument values for the specified Option {@code opt} using the values retrieved from the specified\n     * iterator {@code iter}.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     *\n     * @throws ParseException if an argument value is required and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if {@code arg} does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (opt.getValues() == null || opt.getValues().length == 0) {\n                        try {\n                            opt.addValueForProcessing(value);\n                        } catch (final RuntimeException exp) {\n                            // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Sets the options.\n     *\n     * @param options the options.\n     */\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }\n}\n","_id":"654c9689beaabc9396c879ea"},"operation":{"name":"processOption","parameterTypes":["String","ListIterator"],"_id":"654c9689beaabc9396c879eb"},"identifiers":{"parameters":["arg","iter"],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654c9689beaabc9396c879ec"},"pre":[],"post":[],"throws":[],"__v":0}],"__v":11}