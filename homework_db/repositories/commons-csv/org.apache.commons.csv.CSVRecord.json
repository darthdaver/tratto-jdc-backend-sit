{"name":"org.apache.commons.csv.CSVRecord","jDoctorConditions":[{"source":{"methodJavadoc":"    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */","methodSourceCode":"public String get(final Enum<?> e){\n    return get(e == null ? null : e.name());\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /**\n     * The accumulated comments (if any)\n     */\n    private final String comment;\n\n    /**\n     * The record number.\n     */\n    private final long recordNumber;\n\n    /**\n     * The values of the record\n     */\n    private final String[] values;\n\n    /**\n     * The parser that originates this record. This is not serialized.\n     */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" + Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n}\n","_id":"654bdbc987c1f59108d79aad"},"operation":{"name":"get","parameterTypes":["Enum"],"_id":"654bdbc987c1f59108d79aae"},"identifiers":{"parameters":["e"],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbc987c1f59108d79aaf"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */","methodSourceCode":"public Iterator<String> iterator(){\n    return toList().iterator();\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /**\n     * The accumulated comments (if any)\n     */\n    private final String comment;\n\n    /**\n     * The record number.\n     */\n    private final long recordNumber;\n\n    /**\n     * The values of the record\n     */\n    private final String[] values;\n\n    /**\n     * The parser that originates this record. This is not serialized.\n     */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" + Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n}\n","_id":"654bdbc987c1f59108d79ae9"},"operation":{"name":"iterator","parameterTypes":[],"_id":"654bdbc987c1f59108d79aea"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbc987c1f59108d79aeb"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */","methodSourceCode":"public int size(){\n    return values.length;\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /**\n     * The accumulated comments (if any)\n     */\n    private final String comment;\n\n    /**\n     * The record number.\n     */\n    private final long recordNumber;\n\n    /**\n     * The values of the record\n     */\n    private final String[] values;\n\n    /**\n     * The parser that originates this record. This is not serialized.\n     */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" + Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n}\n","_id":"654bdbc987c1f59108d79af3"},"operation":{"name":"size","parameterTypes":[],"_id":"654bdbc987c1f59108d79af4"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbc987c1f59108d79af5"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */","methodSourceCode":"public Stream<String> stream(){\n    return Stream.of(values);\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /**\n     * The accumulated comments (if any)\n     */\n    private final String comment;\n\n    /**\n     * The record number.\n     */\n    private final long recordNumber;\n\n    /**\n     * The values of the record\n     */\n    private final String[] values;\n\n    /**\n     * The parser that originates this record. This is not serialized.\n     */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" + Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n}\n","_id":"654bdbc987c1f59108d79af8"},"operation":{"name":"stream","parameterTypes":[],"_id":"654bdbc987c1f59108d79af9"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbc987c1f59108d79afa"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */","methodSourceCode":"public List<String> toList(){\n    return stream().collect(Collectors.toList());\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /**\n     * The accumulated comments (if any)\n     */\n    private final String comment;\n\n    /**\n     * The record number.\n     */\n    private final long recordNumber;\n\n    /**\n     * The values of the record\n     */\n    private final String[] values;\n\n    /**\n     * The parser that originates this record. This is not serialized.\n     */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" + Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n}\n","_id":"654bdbc987c1f59108d79afd"},"operation":{"name":"toList","parameterTypes":[],"_id":"654bdbc987c1f59108d79afe"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbc987c1f59108d79aff"},"pre":[],"post":[],"throws":[],"__v":0}],"__v":15}