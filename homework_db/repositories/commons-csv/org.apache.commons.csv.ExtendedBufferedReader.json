{"name":"org.apache.commons.csv.ExtendedBufferedReader","jDoctorConditions":[{"source":{"methodJavadoc":"    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */","methodSourceCode":"int getLastChar(){\n    return lastChar;\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n */\nfinal class ExtendedBufferedReader extends BufferedReader {\n\n    /**\n     * The last char returned\n     */\n    private int lastChar = UNDEFINED;\n\n    /**\n     * The count of EOLs (CR/LF/CRLF) seen so far\n     */\n    private long eolCounter;\n\n    /**\n     * The position, which is the number of characters read so far\n     */\n    private long position;\n\n    private boolean closed;\n\n    /**\n     * Constructs a new instance using the default buffer size.\n     */\n    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            // counter is accurate\n            return eolCounter;\n        }\n        // Allow for counter being incremented only at EOL\n        return eolCounter + 1;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }\n\n    /**\n     * Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)\n     */\n    long getPosition() {\n        return this.position;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect the line number or the last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n        return c;\n    }\n\n    /**\n     * Populates the buffer with the next {@code buf.length} characters in the\n     * current reader without consuming them. The next call to {@link #read()} will\n     * still return the next value. This doesn't affect the line number or the last\n     * character.\n     *\n     * @param buf the buffer to fill for the look ahead.\n     * @return the buffer itself\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final char[] buf) throws IOException {\n        final int n = buf.length;\n        super.mark(n);\n        super.read(buf, 0, n);\n        super.reset();\n        return buf;\n    }\n\n    /**\n     * Returns the next n characters in the current reader without consuming them. The next call to {@link #read()} will still return the next value. This\n     * doesn't affect line number or last character.\n     *\n     * @param n the number characters look ahead.\n     * @return the next n characters.\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final int n) throws IOException {\n        final char[] buf = new char[n];\n        return lookAhead(buf);\n    }\n\n    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR || current == END_OF_STREAM && lastChar != CR && lastChar != LF && lastChar != END_OF_STREAM) {\n            eolCounter++;\n        }\n        lastChar = current;\n        position++;\n        return lastChar;\n    }\n\n    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        final int len = super.read(buf, offset, length);\n        if (len > 0) {\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n            lastChar = buf[offset + len - 1];\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n        position += len;\n        return len;\n    }\n\n    /**\n     * Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise, information can be lost.\n     * <p>\n     * Increments {@link #eolCounter} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        if (lookAhead() == END_OF_STREAM) {\n            return null;\n        }\n        final StringBuilder buffer = new StringBuilder();\n        while (true) {\n            final int current = read();\n            if (current == CR) {\n                final int next = lookAhead();\n                if (next == LF) {\n                    read();\n                }\n            }\n            if (current == END_OF_STREAM || current == LF || current == CR) {\n                break;\n            }\n            buffer.append((char) current);\n        }\n        return buffer.toString();\n    }\n}\n","_id":"654bdbca87c1f59108d79b24"},"operation":{"name":"getLastChar","parameterTypes":[],"_id":"654bdbca87c1f59108d79b25"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbca87c1f59108d79b26"},"pre":[],"post":[],"throws":[],"__v":0},{"source":{"methodJavadoc":"    /**\n     * Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise, information can be lost.\n     * <p>\n     * Increments {@link #eolCounter} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */","methodSourceCode":"public String readLine() throws IOException{\n    if (lookAhead() == END_OF_STREAM) {\n        return null;\n    }\n    final StringBuilder buffer = new StringBuilder();\n    while (true) {\n        final int current = read();\n        if (current == CR) {\n            final int next = lookAhead();\n            if (next == LF) {\n                read();\n            }\n        }\n        if (current == END_OF_STREAM || current == LF || current == CR) {\n            break;\n        }\n        buffer.append((char) current);\n    }\n    return buffer.toString();\n}","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n */\nfinal class ExtendedBufferedReader extends BufferedReader {\n\n    /**\n     * The last char returned\n     */\n    private int lastChar = UNDEFINED;\n\n    /**\n     * The count of EOLs (CR/LF/CRLF) seen so far\n     */\n    private long eolCounter;\n\n    /**\n     * The position, which is the number of characters read so far\n     */\n    private long position;\n\n    private boolean closed;\n\n    /**\n     * Constructs a new instance using the default buffer size.\n     */\n    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            // counter is accurate\n            return eolCounter;\n        }\n        // Allow for counter being incremented only at EOL\n        return eolCounter + 1;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }\n\n    /**\n     * Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)\n     */\n    long getPosition() {\n        return this.position;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect the line number or the last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n        return c;\n    }\n\n    /**\n     * Populates the buffer with the next {@code buf.length} characters in the\n     * current reader without consuming them. The next call to {@link #read()} will\n     * still return the next value. This doesn't affect the line number or the last\n     * character.\n     *\n     * @param buf the buffer to fill for the look ahead.\n     * @return the buffer itself\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final char[] buf) throws IOException {\n        final int n = buf.length;\n        super.mark(n);\n        super.read(buf, 0, n);\n        super.reset();\n        return buf;\n    }\n\n    /**\n     * Returns the next n characters in the current reader without consuming them. The next call to {@link #read()} will still return the next value. This\n     * doesn't affect line number or last character.\n     *\n     * @param n the number characters look ahead.\n     * @return the next n characters.\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final int n) throws IOException {\n        final char[] buf = new char[n];\n        return lookAhead(buf);\n    }\n\n    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR || current == END_OF_STREAM && lastChar != CR && lastChar != LF && lastChar != END_OF_STREAM) {\n            eolCounter++;\n        }\n        lastChar = current;\n        position++;\n        return lastChar;\n    }\n\n    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        final int len = super.read(buf, offset, length);\n        if (len > 0) {\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n            lastChar = buf[offset + len - 1];\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n        position += len;\n        return len;\n    }\n\n    /**\n     * Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise, information can be lost.\n     * <p>\n     * Increments {@link #eolCounter} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        if (lookAhead() == END_OF_STREAM) {\n            return null;\n        }\n        final StringBuilder buffer = new StringBuilder();\n        while (true) {\n            final int current = read();\n            if (current == CR) {\n                final int next = lookAhead();\n                if (next == LF) {\n                    read();\n                }\n            }\n            if (current == END_OF_STREAM || current == LF || current == CR) {\n                break;\n            }\n            buffer.append((char) current);\n        }\n        return buffer.toString();\n    }\n}\n","_id":"654bdbca87c1f59108d79b3d"},"operation":{"name":"readLine","parameterTypes":[],"_id":"654bdbca87c1f59108d79b3e"},"identifiers":{"parameters":[],"receiverName":"receiverObjectID","returnName":"methodResultID","_id":"654bdbca87c1f59108d79b3f"},"pre":[],"post":[],"throws":[],"__v":0}],"__v":7}